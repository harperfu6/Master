\chapter{関連研究}
本章においては，本研究に関する研究について述べる．本研究では，ユーザ定義手書きジェスチャを高速に認識し，かつどのような開発環境においても実装可能な軽量なアルゴリズムを提案している．また，ストロークの大きさ，向き，位置に関して識別可能な\$-Family Recognizerである．よって，本研究の関連研究は，一般的な，手書きジェスチャ認識アルゴリズムの研究，ユーザ定義に特化した手書きジェスチャ認識アルゴリズムの研究，手書きジェスチャ認識を可能にするツールキット，\$-Family Recognizerに関する研究，手書きジェスチャの評価に関する研究に分類される
本章においては，それらの研究について述べた後，最後に本研究における手書きジェスチャ認識アルゴリズムである\$Vの位置づけについて述べる．

\section{手書きジェスチャ認識アルゴリズム}
文字，ストロークの形状，手書きジェスチャなどの認識は，長く広く研究されている分野であり，多くのアルゴリズムにより実現されてきた，
finite state machines~\cite{Hong00constructingfinite}~(有限オートマトン)は，有限個の状態と遷移と動作の組み合わせからなる論理モデルであり，ある「状態」において，何らかのイベントや条件によって別の状態へ「遷移」することを繰り返すことによって最終的な認識結果を導く．高い認識精度を示すためには，より詳細なモデルの定義が必要となる．
Hidden Markov Models~(HMMs)~\cite{Anderson2004HiddenMM,Sezgin:2005:HES:1040830.1040899, Cao:2005:EOA:1089508.1089540}~(隠れマルコフモデル)は，観測された出力の系列から，内部の状態系列を統計的に推測するためのアルゴリズムである．
neural networks~\cite{Pittman:1991:RHT:108844.108914}は脳機能の特性を計算機上に応用したアルゴリズムであり，大量の学習によってモデルを最適化し，多次元量のデータで線形分離不困難な問題に対して比較的小さい計算量で良好な解を得ることができる．
feature-based statistical classifiers~\cite{Cho:2006:NGR:1711617.1711649,Rubine:1991:SGE:127719.122753}は，大量の学習データによる特徴量をもとに学習データをクラスタリングし，より低次元な認識モデルを生成するためのアルゴリズムである．
ad hoc heuristic recognizers~\cite{Anthony:2010:LMR:1839214.1839258, Wilson:2003:XUI:642611.642706}は，「限定的な」認識アルゴリズムであるため，事前に定義されたジェスチャのみ認識することができる．アプリケーション実行時において，新たな学習データを追加した場合に，新たなヒューリスティック関数を定義しなければならないため，アプリケーションユーザが独自にジェスチャを定義することができない．
template matching~\cite{Kara:2005:ITS:1652319.1652712, Kristensson:2004:SLV:1029632.1029640}は．主に画像処理として用いられ，学習データと入力データの画像をそれぞれ走査し，画像上の各位置における類似度を算出するアルゴリズムであり，手書き文字にも応用されている．

これらアルゴリズムはオンライン文字認識及びオフライン文字認識に双方においてしばしば用いられるアリゴリズムである．オンライン文字認識とは，ディスプレイなどにペンや指などによって入力された文字を認識する技術の総称であり，オフライン文字認識とは，紙に書かれた文書イメージを光学スキャンし，そのイメージを自動的にコンピュータで処理可能なテキストデータに変換する技術の総称である．しかしながら，これらアルゴリズムは，高い認識精度を示す認識モデルを生成するために膨大な数の学習データが必要であり，素早く手書きジェスチャ入力のテストしたい場合において不向きであるだけでなく，アプリケーションユーザが独自にジェスチャを定義する上で実用的であるとは言えない．また，これらアルゴリズムを実装することは，本分野に精通していない開発者にとって困難である．

\section{ユーザ定義に特化した手書きジェスチャ認識アルゴリズム}
Rubine classfier~\cite{Rubine:1991:SGE:122718.122753}やDynamic programming~(DTW)~\cite{Tappert:1982:CSR:1664966.1664979}などは，少ない学習データにおいてジェスチャ認識可能なアルゴリズムであるが，Rubine classfierはアルゴリズムに用いられる数式が複雑である上，学習データが少ない場合は認識率が高いとは言えない．また，DTWはアルゴリズムが簡潔であるが，計算量が非常に大きいという問題点がある．計算量を改善したFast DTW~\cite{Salvador:2007:TAD:1367985.1367993}が開発されたが，アルゴリズムは複雑になっており，プロトタイピング環境開発向けとは言い難い．
また，Rubineは多くある特徴量を適切に選ばないと，認識率が低下するという欠点があり，特徴量の選定が難しい．このように認識に用いる特徴量を単に増やすことは，それについて識別できることにつながるが，ロバスト性に欠ける欠点もある．

\section{手書きジェスチャ認識を可能にするツールキット}
プロトタイピング環境向けに開発できるように，ジェスチャ認識を簡単に開発可能なツールキットも開発された．SATIN~\cite{Hong:2000:STI:354401.354412}はペンベースのユーザインタフェースであり，ジェスチャ認識のモデルを手書きによって定義することができ，ジェスチャ認識の開発を容易にしたツールキットである．
Henry et al.~\cite{Henry:1990:IGS:97924.97938}，Landay and Myers~\cite{Landay:1993:EEU:259964.260123}によるツールキットは〜，
Amulet toolit~\cite{Myers:1997:AEN:262050.260628}は〜がある．
これらは，開発を手助けするのに非常に強力であるが，対応可能な開発環境が決まっており，自身の環境に適用できない場合がある．

%\section{Programming by Example}


\section{\$-Family Recognizer}
\$1 \cite{Wobbrock:2007:GWL:1294211.1294238}は，プロトタイピング環境において実装可能であり，少ない学習データにより，高い認識率を示すアルゴリズムであるため，ユーザが独自にジェスチャを定義するジェスチャ認識システムを開発することが可能である．プロトタイプ開発者は，自身のシステムに，簡単な数式のみを含む，およそ100行からなるアルゴリズムを追加するのみによって，図のような単一ストロークからなるジェスチャ認識を行うことが可能である．\$1はgeometric template matchng approachを用い，canditate gestureとtemplate gestureの対応する点のユークリッド距離が最小となるような最適な角度を探索することによってジェスチャ認識を行っている．
しかしながら，ストロークを，大きさ，向き，位置に不変にしているため，それらの特徴量に依存するようなストロークを認識することができないため，そのようなストローク認識を行いたい開発者は\$1を自身のシステムに採用することができない．
\$1が識別/認識することができないストロークを識別/認識するために，これまで\$1を拡張したアルゴリズムが開発されてきた．
\$N \cite{Anthony:2010:LMR:1839214.1839258}は，複数のストロークからなるジェスチャを認識することを可能にし，識別可能なストロークを大幅に増やすことに成功した．\$Nは，ストロークを複数の単一ストロークに分割し，それぞれの単一ストロークを\$1の手法によって認識した．また，自動的にall possible permutations of a multistrokeを計算することによって，ストロークの向きや書く順番にロバストな認識も可能にした．
Quick\$ \cite{Reaver:2011:MQU:2021164.2021183}は，\$1の改良であり，Hierarchical Clusteringによって，対応する点のユークリッド距離が最小となるcanditate gestureとtemplate gestureの組み合わせを効率的に探索し，認識速度を高速化することに成功した．
Protractor \cite{Li:2010:PFA:1753326.1753654}も，\$1に対し，認識速度の面において改良し，最適な角度を探索する際に，GSS \cite{Press:1992:NRC:148286}(pp. 397-402)を用いた\$1とは異なり，a closed-form solutionを用いることによって，より高速に探索することを可能とした．
\$N-Protractor \cite{Anthony:2012:NFA:2305276.2305296}は，\$Nに対し，Protractorの手法を用いることによって，より高速にかつ，より正確に複数のストロークからなるジェスチャを認識することを可能にした
1 cent Recognizer \cite{Herold:2012:CRF:2331067.2331074}は，\$1よりも高速であり，アルゴリズムも非常に単純であるため実装が容易であるが，認識/識別可能なジェスチャの種類や，認識率の観点から見るとあまり実用的であるとは言えない．
\$P \cite{Vatavu:2012:GPC:2388676.2388732}は，ストロークを構成する点をPoint Cloudとして扱うことによって，\$N-Protractorよりも，memoryやexecution costsの点において効率的なアルゴリズムを示した．
Penny Pincher \cite{Taranta:2015:PPB:2788890.2788925}は，ストロークを構成する点間のベクトルを用いることによって，これまでの\$-Family Recognizerと比べて，より高速にかつ，正確に認識することを可能にした．

これらの\$-Family Recognizerは，2Dのストローク認識をすることが可能であり，\$1に対し，アルゴリズムを簡略化したり，認識速度を高速化したり，認識率を高くしたり，認識できるストロークの種類を増やしたりするなどして，繰り返し改善されてきた．

しかしながらこれらのアルゴリズムは，ストロークの特徴量である，大きさ，向き，位置に関して，そのいずれかあるいはすべてについて不変になるようなアルゴリズムを採用することにより，それらの特徴量についてロバストなジェスチャ認識を実現し，その結果認識率や，認識速度の向上を実現してきた．
それらを不変にしないことは，その特徴量について識別できるようになることにつながるが，不変にしない特徴量についてはロバストではなくなるため，認識率の低下や認識速度の低下を招く恐れがある．例えば，1 cent Recognizerはストロークを構成するすべての点の中心座標から，それぞれの点へのユークリッド距離のみを特徴量とし，canditate gestureとtemplate gestureの特徴量の差が最小となるストロークを探索しているため，ストロークの形状は同じであるが，大きさ，向き，位置に関して異なるストロークを識別することは可能である．しかし，それぞれの特徴量についてロバストでないため，それぞれの特徴量について微妙に異なる場合，認識できないことが多々あり，結果的に認識率の低下を招く．認識速度の観点でいえば，DTWは，単純にストロークを構成する点の距離を比較するのみであるため，こちらも，ストロークの形状は同じであるが，大きさ，向き，位置に関して異なるストロークを識別することは可能であるが，認識率を向上させるために，非常に計算量が大きい．

\section{手書きジェスチャの評価研究}


\section{本研究の位置づけ}






