\chapter{\$1アルゴリズム}
\$Vは\$1の拡張であるため，本章において\$1アルゴリズムについて述べる．

\section{特徴}
ユーザが入力した手書きジェスチャは，図のように複数の点によって構成され，すでに登録された手書きジェスチャと，それぞれの点を比較することによって，どの手書きジェスチャと一致しているかが判別される．しかしながら，これらの手書きジェスチャを構成する複数の点は，入力に用いているハードウェアやソフトウェアに依存した速度によってサンプリングされる．それに加え，人間によって入力される手書きジェスチャはばらつきがあるため，入力される手書きジェスチャを構成する点の数は入力されるたびに異なる．
そのため，ユーザが入力した手書きジェスチャと，すでに登録された手書きジェスチャを比較するにあたり，手書きジェスチャを構成する点どうしを単純に比較することは困難であると言える．


例えば，図のような``pigtail''と``x''の手書きジェスチャのそれぞれのペアにおいて，手書きジェスチャの大きさや，手書きジェスチャを構成する点の数が異なる．この特徴は，手書きジェスチャ認識において双方を比較する上で，1つのハードルとなっている．
また，pigtailは回転することによってxと似た手書きジェスチャとなる．これらの問題に対処しつつ，単純なアルゴリズムを実現するために，以下のような基準に従うようなアルゴリズムの実現を目指した．

\begin{itemize}
\item ハードウェアやソフトウェアのセンシング及び入力する速度などによって変わるサンプリングされる点の数の違いに対してロバストであること．
\item 手書きジェスチャの大きさ，向き，位置の不変に関してオプショナルに設定可能であること．
\item 数学的な高度な知識やテクニックをを必要としないこと~(例えば，逆行列，微分，積分など)
\item 少ないコードによって実装できること．
\item 認識速度が速いこと．
\item ソフトウェア開発者やアプリケーションユーザが，独自に手書きジェスチャを定義できること．
\item N-best listに関して，高い識別能力を示すスコアを示すこと．
\item 図\ref{fig:stroke_1}のような単一ストロークからなる手書きジェスチャを認識するにあたり，HCI分野において多く用いられる既存の複雑な手書きジェスチャ認識アルゴリズムと比べても，高い認識率を示すこと．
\end{itemize}

ここで，N-best listとは，N個の学習データそれぞれに対する入力データとの類似度を降順に並べたものであり，N-best listの最高値と２番目の値の差が大きいほど，高い識別能力を示していると言える．

次に，これらの基準に従うような\$1のアルゴリズムを述べる．
アルゴリズムは大きく4つのステップから構成される．


\section{4つのステップ}
前節において述べた基準を満たすために，入力データ及び学習データは4つのステップを経た後に比較される．
4つのステップは，リサンプル，向きの正規化，大きさと位置の正規化，〜からなる．

\subsection{リサンプル}
前節において述べたように，手書きジェスチャを構成する点の数は，ハードウェアやソフトウェアのセンシング及び入力する速度などによって変わる．特に，入力速度の違いによる点の数の違いは顕著である．(図)

点の数が違うことにより，入力データと学習データの手書きジェスチャを構成する点を互いに比較することが困難となっている．そこで，図に示すようにN個の等間隔に並ぶ点にリサンプルすることとする．N個の点にリサンプルすることは，生のデータを扱うことと比べて正確なデータを扱っているとは言えず認識精度が落ちる可能性があるが，入力データと学習データ双方の手書きジェスチャの点の数が等しくなるため，容易に互いの対応する点を比較できる．

リサンプルすることは，既存の手書きジェスチャ認識アルゴリズムにおいても用いられている~\cite{Plamondon:2000:OOH:331097.331275, Tappert:1990:SAO:83123.83137, Kristensson:2004:SLV:1029632.1029640, Zhai:2003:SWS:642611.642630, Tappert:1982:CSR:1664966.1664979}．\$1はこれらのアルゴリズムを採用するとともに，これらのアルゴリズムとは違い向きに不変なアルゴリズムを提供する．また，手書きジェスチャを構成する点の数をリサンプルすることなく実行可能なDTWと比較している．

N個の等間隔に並ぶ点にリサンプルする方法を図に示す．
\TODO{リサンプルの仕方を図で説明}

また，32<N<256の時，N=64の時が最適であることがわかった．

\subsection{向きの正規化}
リサンプルされた手書きジェスチャの向きを``indicative angle''として定義する．indicative angleとは図のように，手書きジェスチャの書き始めの一番最初の点の座標，手書きジェスチャを構成する点全てによる中心座標，0度方向によって形成される角度である．そして，indicative angleの沿って，全てのジェスチャを回転させる．これにより，ジェスチャは向きに正規化される．


\subsection{大きさと位置の正規化}
向きによって正規化されたジェスチャの大きさを``boundingbox''として定義する．boundingboxとは図のように，ジェスチャに隣接するような矩形を示す．全てのジェスチャについて，boundingboxをある一定の大きさの矩形に正規化することによって，ジェスチャは大きさに正規化される．

大きさによって正規化されたジェスチャの位置をジェスチャを構成する全ての点による中心座標として定義する．全てのジェスチャについて(0, 0)へと移動させることによって，向きに正規化される．

\subsection{類似度を高くするための最適な角度}
リサンプルされた２つの手書きジェスチャ構成する点を1つずつ対応する点どうし比較するにあたり，1度ずつ手書きジェスチャを回転させながら，最も類似度が高くなるような角度を見つけた上で，類似度を算出する方法~\cite{Kara:2005:ITS:1652319.1652712}は認識のために膨大な時間を要することになる．学習データの数が全て含めて30くらいであればそのような方法でも十分な速度によって認識することが可能であるが，\$1は黄金分割探索~\cite{Press:1992:NRC:148286}を用いる．
黄金分割探索とは，単峰関数~(極値が1つしかない関数)において，極値を求めるための方法~(局所探索法)のうち効率的な方法の1つであり，極値が存在することが自明な範囲において極値を逐次的に求める方法である．

例えば図のように，f(x)の関数があり，極小値f(x')を求める時に，x1とx3の間に極値が存在することが自明な時に，その範囲内に存在するf(x2)を求める．この時x2は(x2 - x1) : (x3 - x2)が黄金比~(\TODO{黄金比入れる})となるように設定する．これが黄金分割探索と言われる所以であり，常に3点~(この場合x1, x2, x3)が存在する．その後広い区間~(この場合x2とx3の間)において，同様に黄金比によって分割し新たなf(x4)を得る．この時，f(x4a)ならば，極小値はx1とx4の間に存在するため，新たな3点はx1, x2, x4となる．f(x4b)ならば，極小値はx2とx3の間に存在するため，新たな3点はx2, x4, x3となる．このように，極小値が存在する範囲を徐々に狭めていくことによって，効率よく極小値を求めることができる．

\$1の場合，480個の手書きジェスチャにおいて，+-45度の範囲において極小値が存在することが発見され，極小値が存在する範囲が2度になるまで黄金分割探索を行う．この時，入力データに類似する学習データが存在する場合あるいはしない場合においても，10ステップ後には極小値が求められることが発見された．

局所探索法の1つである山登り法(引用)を黄金分割探索の代わりに用いる場合，480個の手書きジェスチャにおいて，類似するジェスチャの場合およそ7.2ステップ後に極小値を求めることができるが，類似するジェスチャが存在しない場合はおよそ53.5ステップ後に極小値が求められる．つまり学習データが10ずつ存在する16種類の手書きジェスチャ=160において，黄金分割探索は160\time10 = 1600ステップ必要であるのに対し，山登り法は7.2\time10 + 53.5\time150 = 8097ステップ必要であり，およそ80.2\%もの計算量の節約となっている．

このように，類似度を高くするための最適な角度を黄金分割探索によって効率的に求めることによって，認識速度の向上を実現している．

以上の4ステップをまとめ，入力データと学習データそれぞれを比較するまでの過程を図\ref{fig:algorithm_1}に示す．
\begin{figure} [!h]
\centering
\includegraphics [width=0.8\columnwidth]{img/algorithm_1.eps}
\caption{Each step in the \$1 algorithm process}
\label{fig:algorithm_1}
\end{figure}

\subsection{類似度計算}
前節までの4ステップによって得られた入力データと学習データの最終的な類似度計算は式~(1)及び式~(2)によって表される．
\TODO{式を載せる}
ここで〜\TODO{式の説明}

\section{リミテーション}
\$1は，手書きジェスチャを，大きさ，向き，位置に正規化することによってアルゴリズム全体を簡潔化したり，それぞれについてロバストな認識を可能にし認識率の向上を実現した．しかしながら，このことが原因により，幾つかのリミテーションが存在する．

\begin{itemize}
\item 手書きジェスチャを大きさ，向き，位置によって識別しない．
\item 直線のような1次元の手書きジェスチャを認識することができない．
\item 手書きジェスチャを入力する速度による識別ができない．
\end{itemize}


「手書きジェスチャを大きさ，向き，位置によって識別しない」ことに関しては，それぞれについて正規化しないようにアルゴリズムを変えることによって識別することが可能となる．しかしながら，正規化しないことにより，正規化しないものに関してはロバスト性が低下するため，結果的に認識率の低下を招く恐れがある．

「直線のような1次元の手書きジェスチャを認識することができない」ことに関しては，向き，大きさに関して正規化した際に図のようになるためである．

「手書きジェスチャを入力する速度による識別ができない」ことに関しては，入力速度の要素を特徴量として用いることによって識別可能となる．例えば，Rubine~\cite{Rubine:1991:SGE:122718.122753}のような特徴量ベースの認識は，速度を特徴量として用いている．このように認識に用いる特徴量が複数存在する場合，用いる特徴量を適切に選択できれば，つまり，認識に本当に必要な特徴量のみを用いて，認識には必要のない特徴量を選択できれば，認識率の高い手書きジェスチャ認識アルゴリズムとなる．しかしながら，一般的に手書きジェスチャ認識アルゴリズムに関する深い知識がない限り，そのような適切な選択は困難である．\$1は，識別可能な特徴量が少ないが，そのようなわずらわしさを一切省いたアルゴリズムとなっている．



